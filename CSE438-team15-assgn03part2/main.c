#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <linux/input.h>
#include <stdio.h>
#include <stdlib.h>
#include <linux/ioctl.h>
#include <sched.h>
#include <unistd.h>
#include <linux/kernel.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <inttypes.h>
#include <pthread.h>
#define CONFIG 1
#define DISPLAY "/dev/DISPLAY"
#define DISTANCE "/dev/DISTANCE"
int result;
pthread_mutex_t mutex;

pthread_mutex_t distance_lock = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t display_lock = PTHREAD_MUTEX_INITIALIZER;
 
uint8_t pattern[10];
//pattern sequence depending on the distance
uint8_t pattern1[10]= {1,35,2,40,3,35,4,40,0,0};
uint8_t pattern2[10]= {5,35,6,35,7,35,8,35,0,0};
uint8_t pattern3[10]=  {9,40,10,40,11,40,0,0,0,0};
//pattern matrix to be send using the ioctl function
uint8_t array[12][24]= {
		{0x0C, 0x01,0x09, 0x00,	0x0A, 0x0F,0x0B, 0x07,0x01, 0x00,0x02, 0x00,0x03, 0x00,0x04, 0x00,0x05, 0x00,0x06, 0x00,0x07, 0x00,0x08, 0x00,},
		{0x0C, 0x01,0x09, 0x00,	0x0A, 0x0F,0x0B, 0x07,0x01, 0x3C,0x02, 0x42,0x03, 0xA5,0x04, 0x81,0x05, 0xA5,0x06, 0x99,0x07, 0x42,0x08, 0x3C,},
		{0x0C, 0x01,0x09, 0x00,	0x0A, 0x0F,0x0B, 0x07,0x01, 0x3C,0x02, 0x42,0x03, 0xA5,0x04, 0x81,0x05, 0xBD,0x06, 0x81,0x07, 0x42,0x08, 0x3C,},
		{0x0C, 0x01,0x09, 0x00,	0x0A, 0x0F,0x0B, 0x07,0x01, 0x3C,0x02, 0x42,0x03, 0xA5,0x04, 0x81,0x05, 0xBD,0x06, 0x99,0x07, 0x42,0x08, 0x3C,},
		{0x0C, 0x01,0x09, 0x00,	0x0A, 0x0F,0x0B, 0x07,0x01, 0x3C,0x02, 0x42,0x03, 0xA5,0x04, 0x81,0x05, 0xBD,0x06, 0x8D,0x07, 0x42,0x08, 0x3C,},

		{0x0C, 0x01,0x09, 0x00,	0x0A, 0x0F,0x0B, 0x07,0x01, 0xFF,0x02, 0x81,0x03, 0x81,0x04, 0x81,0x05, 0x81,0x06, 0x81,0x07, 0x81,0x08, 0xFF,},
		{0x0C, 0x01,0x09, 0x00,	0x0A, 0x0F,0x0B, 0x07,0x01, 0xFF,0x02, 0x81,0x03, 0xBD,0x04, 0xA5,0x05, 0xA5,0x06, 0xBD,0x07, 0x81,0x08, 0xFF,},
		{0x0C, 0x01,0x09, 0x00,	0x0A, 0x0F,0x0B, 0x07,0x01, 0x00,0x02, 0x00,0x03, 0x3C,0x04, 0x24,0x05, 0x24,0x06, 0x3C,0x07, 0x00,0x08, 0x00,},
		{0x0C, 0x01,0x09, 0x00,	0x0A, 0x0F,0x0B, 0x07,0x01, 0xFF,0x02, 0x81,0x03, 0xBD,0x04, 0xA5,0x05, 0xA5,0x06, 0xBD,0x07, 0x81,0x08, 0xFF,},
		
		{0x0C, 0x01,0x09, 0x00,	0x0A, 0x0F,0x0B, 0x07,0x01, 0x00,0x02, 0x00,0x03, 0x00,0x04, 0x00,0x05, 0x18,0x06, 0x3C,0x07, 0x3C,0x08, 0x18,},
		{0x0C, 0x01,0x09, 0x00,	0x0A, 0x0F,0x0B, 0x07,0x01, 0x00,0x02, 0x00,0x03, 0x18,0x04, 0x3C,0x05, 0x3C,0x06, 0x18,0x07, 0x00,0x08, 0x00,},
		{0x0C, 0x01,0x09, 0x00,	0x0A, 0x0F,0x0B, 0x07,0x01, 0x18,0x02, 0x3C,0x03, 0x3C,0x04, 0x18,0x05, 0x00,0x06, 0x00,0x07, 0x00,0x08, 0x00,},
};
//thread function to display the patterns on LED matrix

void* displayFunction(void* parameters)
{
	int fd3,fd4;
	fd3 = open(DISPLAY, O_RDWR);
	if(fd3<0)
		printf("opening error");
	fd4=ioctl(fd3,1,array);
	if(fd4<0)
	{
	//errno = EINVAL;
		printf("error in ioctl\n");
	} 
	while(1)
	{
		pthread_mutex_lock(&display_lock);
		fd4=write(fd3,(void*)pattern, sizeof(pattern));
		if(fd4<0)
			{
				//errno = EINVAL;
				printf("error in reading\n");
			}
		pthread_mutex_unlock(&display_lock);
		//usleep(120000);
	} 
	close(fd3);
	return 0;
}
//thread function to measure the distance
void* distanceFunction(void* parameters)
{
	int fd,fd1,fd2;
	int distance;

	int i;
	//printf("\n %lld ", *ptr);
	fd = open(DISTANCE, O_RDWR);
	if(fd<0)
		printf("opening error");

	while(1)
	{
		fd1=write(fd,&distance,1);
		if(fd1<0)
		{
			//errno = EINVAL;
			//printf("error in writing\n");
		}

		fd2=read(fd, &distance,sizeof(distance));
		if(fd2<0)
		{
			//errno = EINVAL;
			//printf("error in reading\n");
		}
		//change the display pattern according to the distance
		pthread_mutex_lock(&distance_lock);	
		result = distance * 0.017;
		if(result<150||result>0)
		{
			if(result<40)
			{
				for(i=0;i<10;i++)
				{
					pattern[i] = pattern1[i];
				}
			}
			else if(result<80)
			{
				for(i=0;i<10;i++)
				{
					pattern[i] = pattern2[i];
				}
		
			}
			else 
			{
				for(i=0;i<10;i++)
				{
					pattern[i] = pattern3[i];
				}
			
			}
	
			printf("\n %d ", result);
		}
			pthread_mutex_unlock(&distance_lock);	
			usleep(50000);
	}
	close(fd);
	return 0;
}


int main() 
{

	//thread create

	pthread_t sensor_thread;
	pthread_create (&sensor_thread, NULL, &distanceFunction, NULL);

	pthread_t display_thread;
	pthread_create (&display_thread, NULL, &displayFunction, NULL);

	pthread_join(sensor_thread, NULL);
	pthread_join(display_thread, NULL);
	return 0;
}	
